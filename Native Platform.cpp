//Main Platform
 //Includes
  #include "Includes\framework.h"
  #include "Includes\Native Platform.h"
  #include <string>
  #include <dos.h>
  #include <chrono>
  #include <thread>
  #define MAX_LOADSTRING 50 
 //-//
 //System
  HINSTANCE hInst; WCHAR szTitle[MAX_LOADSTRING]; WCHAR szWindowClass[MAX_LOADSTRING]; ATOM MyRegisterClass(HINSTANCE hInstance); BOOL InitInstance(HINSTANCE, int); LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); HBITMAP LayerOut; RECT Tempo; HDC HDCl01; HDC hdcP; HWND HwnD; std::jthread SystemThread; std::time_t tempF; std::string temp2; std::wstring temp; std::chrono::steady_clock::time_point Timminging; std::chrono::steady_clock::time_point Timminging2; std::chrono::steady_clock::time_point NowTime; std::chrono::steady_clock::time_point NowTimeEx; COLORREF Display[8294400]; COLORREF Screening[8294400]; void Paintting(); void MainPlat(); void ID(); double temporally; double temporally2; double temporally3; int temporally4; int countw; int counth; double countbitw; double countbith; unsigned long long int AppRuntime = 0; bool DynamicFPS = false; int LayerX = 0; int LayerY = 0; int LayerW = 794; int LayerH = 550; int DisplayW = 794; int DisplayH = 550; double DisplayRatio = 1; bool Running = true; bool FStart = true; int FC = 0; int FCR = 4; int FPI = 0; int FPS = 0; bool ShowFPS = false; int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) { UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_NATIVEPLATFORM, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); if(!InitInstance(hInstance, nCmdShow)){return FALSE;} HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_NATIVEPLATFORM)); MSG msg; hdcP = GetDC(HwnD); Timminging = std::chrono::steady_clock::now(); std::jthread SystemThread(MainPlat); while(GetMessage(&msg, nullptr, 0, 0)) { if(!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)){TranslateMessage(&msg); DispatchMessage(&msg);} } return (int) msg.wParam; } ATOM MyRegisterClass(HINSTANCE hInstance) { WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_NATIVEPLATFORM)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_NATIVEPLATFORM); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&wcex); } BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) { HWND hwnding = GetDesktopWindow(); GetWindowRect(hwnding, &Tempo); hInst = hInstance; HwnD = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, (Tempo.right / 2) - (LayerW / 2), (Tempo.bottom / 2) - (LayerH / 2) - 30, 810, 589, nullptr, nullptr, hInstance, nullptr); DeleteObject(hwnding); if (!HwnD){return FALSE;} ShowWindow(HwnD, nCmdShow); return TRUE; } LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_DESTROY: Running = false; PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0; } void Timming() { NowTime = std::chrono::steady_clock::now(); NowTimeEx = Timminging + std::chrono::milliseconds(8 * ((FPI * FCR) + FC)); while(NowTime > NowTimeEx) NowTimeEx += std::chrono::milliseconds(8); if(DynamicFPS) { while(NowTime < NowTimeEx - std::chrono::microseconds(1500)) NowTime = std::chrono::steady_clock::now(); } else { std::this_thread::sleep_until(NowTimeEx - std::chrono::microseconds(6666)); } return; } void MainPlat() { Run: Timming(); Timminging2 = std::chrono::steady_clock::now(); if(Timminging + std::chrono::seconds(1) < Timminging2) { AppRuntime += 1; if(AppRuntime == 18446744073709551614) AppRuntime = 1000; Timminging += std::chrono::seconds(1); FPS = FPI; FPI = 0; } FC += 1; if(FC != FCR) if(Running){goto Run;} else {return;} FC = 0; FPI += 1; ID(); Paintting(); if(Running){goto Run;} else {return;} } double Rerounding(double Varb01){return (Varb01 - (double)(int)Varb01);} double InvertionR(double Varb01){return 1 - (Varb01 - (double)(int)Varb01);} int Rounding(double Varb01){if(Varb01 > (double)(int)Varb01 + 0.5) return (int)Varb01 + 1; return (int)Varb01;} void Paintting() { GetWindowRect(HwnD, &Tempo); LayerW = -Tempo.left + Tempo.right - 16; LayerH = -Tempo.top + Tempo.bottom - 39; countw = 0; counth = 0; temporally = (double)DisplayW / (double)LayerW ; temporally2 = (double)DisplayH / (double)LayerH; if(temporally >= 1){temporally3 = std::fmod(temporally, 1);} else {temporally3 = temporally;} if(temporally2 >= 1){countbith = std::fmod(temporally2, 1);} else {countbith = temporally2;} while(counth < LayerH) { countw = 0; countbitw = temporally3; while(countw < LayerW) { if(countbitw == (double)(int)countbitw) { if(countbith == (double)(int)countbith) { Screening[(counth * (LayerW)) + countw] = Display[((int)countbith * (DisplayW)) + (int)countbitw]; } else { temporally4 = ((int)countbith * (DisplayW)) + (int)countbitw; Screening[(counth * (LayerW)) + countw] = RGB(Rounding(((double)GetRValue(Display[temporally4]) * InvertionR(countbith)) + ((double)GetRValue(Display[temporally4 + DisplayW]) * Rerounding(countbith))), Rounding(((double)GetGValue(Display[temporally4]) * InvertionR(countbith)) + ((double)GetGValue(Display[temporally4 + DisplayW]) * Rerounding(countbith))), Rounding(((double)GetBValue(Display[temporally4]) * InvertionR(countbith)) + ((double)GetBValue(Display[temporally4 + DisplayW]) * Rerounding(countbith))));}} else {if(countbith == (double)(int)countbith){temporally4 = ((int)countbith * (DisplayW)) + (int)countbitw; Screening[(counth * (LayerW)) + countw] = RGB(Rounding(((double)GetRValue(Display[temporally4]) * InvertionR(countbitw)) + ((double)GetRValue(Display[temporally4 + 1]) * Rerounding(countbitw))), Rounding(((double)GetGValue(Display[temporally4]) * InvertionR(countbitw)) + ((double)GetGValue(Display[temporally4 + 1]) * Rerounding(countbitw))), Rounding(((double)GetBValue(Display[temporally4]) * InvertionR(countbitw)) + ((double)GetBValue(Display[temporally4 + 1]) * Rerounding(countbitw)))); } else { temporally4 = ((int)countbith * (DisplayW)) + (int)countbitw; Screening[(counth * (LayerW)) + countw] = RGB(Rounding(((double)GetRValue(Display[temporally4]) * InvertionR(countbitw) * InvertionR(countbith)) + ((double)GetRValue(Display[temporally4 + 1]) * Rerounding(countbitw) * InvertionR(countbith)) + ((double)GetRValue(Display[temporally4 + DisplayW]) * Rerounding(countbith) * InvertionR(countbitw)) + ((double)GetRValue(Display[temporally4 + DisplayW + 1]) * Rerounding(countbitw) * Rerounding(countbith))), Rounding(((double)GetGValue(Display[temporally4]) * InvertionR(countbitw) * InvertionR(countbith)) + ((double)GetGValue(Display[temporally4 + 1]) * Rerounding(countbitw) * InvertionR(countbith)) + ((double)GetGValue(Display[temporally4 + DisplayW]) * Rerounding(countbith) * InvertionR(countbitw)) + ((double)GetGValue(Display[temporally4 + DisplayW + 1]) * Rerounding(countbitw) * Rerounding(countbith))), Rounding(((double)GetBValue(Display[temporally4]) * InvertionR(countbitw) * InvertionR(countbith)) + ((double)GetBValue(Display[temporally4 + 1]) * Rerounding(countbitw) * InvertionR(countbith)) + ((double)GetBValue(Display[temporally4 + DisplayW]) * Rerounding(countbith) * InvertionR(countbitw)) + ((double)GetBValue(Display[temporally4 + DisplayW + 1]) * Rerounding(countbitw) * Rerounding(countbith))));}} countbitw += temporally; countw += 1;} countbith += temporally2; counth += 1;} LayerOut = CreateBitmap(LayerW, LayerH, 1, 8*4, Screening); HDCl01 = CreateCompatibleDC(hdcP); SelectObject(HDCl01, LayerOut); BitBlt(hdcP, LayerX, LayerY, LayerW, LayerH, HDCl01, 0, 0, SRCCOPY); if(ShowFPS){temp2 = std::to_string(FPS); temp = std::wstring(temp2.begin(), temp2.end()); TextOutW(hdcP, 0, 0, temp.c_str(), 3);} DeleteObject(LayerOut); DeleteDC(HDCl01); return;}
 //-//
//-//
 
//Game
 //Memorized Variables
  int Varb0001;
  int ScreenCount = 0;
  int ScreenCount2 = 0;
  int ScreenCount3 = 0;
 //-//
 
 //System
  void ID()
  {

   ShowFPS = true;
   ScreenCount3 += 1;
   if(ScreenCount3 == 256){ScreenCount3 = 0; ScreenCount2 += 1;}
   if(ScreenCount2 == 256){ScreenCount2 = 0; ScreenCount += 1;}
   if(ScreenCount == 256) ScreenCount = 0;
   for(Varb0001 = 0; Varb0001 < 794 * 550; ++Varb0001)
   Display[Varb0001] = RGB(ScreenCount, ScreenCount2, ScreenCount3 + Varb0001);

   for(Varb0001 = 100; Varb0001 < 200; ++Varb0001)
   for(temporally4 = 125; temporally4 < 225; ++temporally4)
   Display[(DisplayW * temporally4) + Varb0001] = RGB(125, 125, 125);

   return;
  }
 //-//
//-//